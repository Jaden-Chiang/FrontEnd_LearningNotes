## 148. 链表排序

### 题目描述

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。



### 解答

#### 1. 相关知识点

`归并排序（自顶向下和自底向上）`, `找到链表中点（快慢指针法）`, `合并有序链表`



#### 2. 解答

##### 2.1 递归归并（自顶向下）

使用递归的方法，将链表不断地从中点拆分成两个链表，然后再将两个链表合并为升序列表。其中，递归结束的判断条件是：链表中没有节点或只有一个节点

- 注1：此处为递归结束的判断条件。同时，在这里已经判断了`head`和`head.next`均不为`null`，因此下方可以直接新建 `slow = head; fast = head.next`

- 注2：刚开始这个方法一直提示栈溢出，其实就是因为这里没有写对，在将一个链接拆分为两个时，要注意虽然我们设定的`slow`指针，此时是指向了中间节点，将链表划分为了 `head -- slow` 和 `slow.next -- tail` 两个部分，但其实此时 `slow` 的 `next` 指针仍存在，即没有切分数组，因此会一直进行切分。正确的方法是在这里，先新建一个 `mid` 指针记录 `slow.next`，然后将 `slow.next`设置为`null`，这样就可以把链接切分了

![image16](../../images/16.png)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function(head) {
    return mergeSort(head);
};

const mergeSort = (head) => {
    // 设置递归结束条件：子序列为空，或子序列长度为1
    if (head == null || head.next == null) return head; // {注1}
    let slow = head; // 慢指针，一次走一步
    let fast = head.next; // 快指针，一次走两步
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    let mid = slow.next; //{注2} 
    slow.next = null;
    let left = mergeSort(head);
    let right = mergeSort(mid);
    return mergeLinkedList(left, right);
};

const mergeLinkedList = (list1, list2) => {
    let sentinal = new ListNode(0);
    let temp = sentinal;
    let p1 = list1;
    let p2 = list2;
    while (p1 != null && p2 != null) {
        if (p1.val < p2.val) {
            temp.next = p1;
            p1 = p1.next;
        } else {
            temp.next = p2;
            p2 = p2.next;
        }
        temp = temp.next;
    }
    if (p1 !== null) temp.next = p1;
    if (p2 !== null) temp.next = p2;
    return sentinal.next;
};
```


