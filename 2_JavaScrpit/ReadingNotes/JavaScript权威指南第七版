## **第3章 类型、值和变量**

### **3.1 概述与定义**

- JavaScript类型可以分为两类：**原始类型**和**对象类型**
- 常量使用 `const` 声明, 变量使用 `let` 声明, *var* 已经不使用了

### **3.2 数值**

### **3.2.3 JavaScript中的算术**

```
 Math.pow(2,53) // => 2的53次方
 Math.round(.6) // => 1.0: 四舍五入到最接近的整数
 Math.ceil(.6) // => 1.0: 向上取最接近的整数
 Math.floor(.6) // => 0.0: 向下舍入到最接近的整数
 Math.abs(-5) // => 5: 绝对值
 Math.max(x,y,z) // 返回最大数
 Math.min(x,y,z) // 返回最小数
```

### **3.2.5 通过BigInt表示任意精度整数**

- BigInt 字面量写作一串数字后跟小写字母`n`, 如: `1000n`, `1234n`

### **3.3 文本**

### **3.3.3 使用字符串**

- JavaScript 中的字符串是**不可修改**的, 如 `replace()` 和 `toUpperCase()` 这样的方法都返回新字符串

### **3.4 布尔值**

- 六个假性值: `undefined`, `null`, `0` , `0`, `NaN`, `""`, 这些值都相当于 `false`

### 3.8 不可修改的原始值与可修改的对象引用

- 对象不是按值比较的，两个不同的对象即使拥有完全相同的属性和值，也不想等。两个不同的数组，即使每个元素都相同，顺序也相同，它们也不相等
- 把对象（或数组）赋值给一个变量，其实是在赋值引用，并不会创建对象的新副本

```jsx
let a = [1, 2, 3];
let b = [1, 2, 3];
console.log(a === b); // => false, a 和 b是两个不同的数组
console.log(a == b); // => false, == 判断依然是不同数组

let c = a;
c.push(4);
console.log(a); // => [1,2,3,4]，在修改c的时候，a也发生了改变，因为c复制的是a的一个引用
console.log(c); // => [1,2,3,4]

let d = [1];
let e = 1;
console.log(d == e); // => true, == 会进行宽松相等测试，会将数组转换为原始值
```

### 3.9 类型转换

#### 3.9.2 显式转换

- `parseInt()` 和 `parseFloat()` 都会跳过开头的空格，尽量多地解析数字字符

### 3.10 变量声明与赋值

#### 3.10.1 使用`let`和`const`声明

- 变量通过`let`关键字声明，如果在`let`语句中不为变量指定初始值，变量也会被声明，并被赋值为`undefined`
- `const`必须在声明时初始化常量
- `let`和`const`声明的变量具有块作用域
- 如果声明位于顶级，在任何代码块的外部，则称其为全局变量或全局常量，具有全局作用域

#### 3.10.2 使用`var`的变量声明

- var最不寻常的一个特性是作用域提升(hoisting)，使用`var`声明的变量，声明会被提升到函数顶部，但初始化仍然在代码所在处，即函数内可以在初始化变量前使用这个变量而不报错(undefined)，这也是`let`要纠正的一个重要错误

```jsx
const func = () => {
	console.log(i); // => undefined, 不会报错
	var i = 1;
}
```

## 第4章 表达式与操作符

### 4.4 属性访问表达式

- JavaScript定义了两种访问属性的语法：

  - expression.identifier
  - expression[expression]

  ```jsx
  let j = {'a': 1, 'b': 2}
  console.log(j.a); // => 1
  console.log(j['a']); // => 1
  ```

## 第5章 语句

### 5.4 循环语句

#### 5.4.4 for/of

- ```
  for/of
  ```

   循环专门用于可迭代对象（数组，字符串，集合和映射），而对象是不可迭代的，因此可以使用

  ```
  for/in
  ```

  方法或

  ```
  基于Object.keys()
  ```

  对对象的属性进行迭代：

  - Object.keys()对对象属性名进行迭代

    ```jsx
    let m = {'a': 1, 'b': 2, 'c': 3};
    for (let item in Object.keys(m)) {
    	console.log(item); // => a, b, c
    }
    ```

  - Object.values()对对象值进行迭代

    ```jsx
    let m = {'a': 1, 'b': 2, 'c': 3};
    for (let item in Object.values(m)) {
    	console.log(item); // => 1, 2, 3
    }
    ```

  - Object.entries()对对象的键值数组进行迭代，注意使用时要**配合解构赋值**

    ```jsx
    let m = {'a': 1, 'b': 2, 'c': 3};
    for (let [key, value] in Object.entries(m)) {
    console.log(key); // => a, b, c	
    console.log(value); // => 1, 2, 3
    }
    ```

### 5.7 声明

#### 5.7.2 function

- 无论在作用域什么地方声明函数，这些函数都会被“提升“，因此在程序中，调用函数的代码可能位于声明函数的代码之前，但类`class`不行。



## 第6章 对象

### 6.1 对象简介

- 对象是一个属性的无序集合

  > An object is an unordered collection of *properties*

- JavaScript对象也可以从其他对象继承属性, 这个其他对象称为其"原型"

  > A JavaScript object also inherits the properties of another object, known as its "prototype"

### 6.2 创建对象

- 创建对象的三种方式:

  1. 通过对象字面量(Object Literals)
  2. `new`关键字
  3. `Object.create()`

  ```javascript
  let point = {x: 0, y: 1}; // 通过对象字面量
  
  ```

  

#### 6.2.4 Object.create()

